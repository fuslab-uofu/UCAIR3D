# histogram.py
from typing import Iterable, Optional, Tuple, Union
import numpy as np

from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import pyqtSignal, Qt

from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

from superqt import QRangeSlider, QDoubleRangeSlider

# generated by pyuic5 from your Designer .ui
from .histogramUI import Ui_histrogramFrame


Number = Union[int, float]


class Histogram(QtWidgets.QFrame):
    """
    Thin wrapper around the Designer UI (Ui_histrogramFrame).
    Own this class; never edit the generated file.

    Features:
      - Matplotlib histogram embedded in ui.hist_plot_frame
      - Log scale toggle (ui.log_checkbox)
      - Clip toggle (ui.clip_checkbox) – just emits a signal; clipping is up to the parent
      - Stacked range sliders (int/float) inserted above the Min/Max edits
      - Vertical limit lines synced to slider values
      - Public API to set data/range/values and query state
    """

    # Signals
    rangeChanged = pyqtSignal(object, object)           # (lo, hi) – emitted whenever slider OR edits change
    # logToggled = pyqtSignal(bool)                       # emitted when Log checkbox toggles
    # clipToggled = pyqtSignal(bool)                      # emitted when Clip checkbox toggles
    # minEdited = pyqtSignal(object)
    # maxEdited = pyqtSignal(object)

    def __init__(
        self,
        parent: Optional[QtWidgets.QWidget] = None,
        *,
        slider_style: Optional[str] = None,   # for your superqt style workaround
        default_is_float: bool = True,
        bins: int = 256,
        tag: Optional[str] = None,            # for debugging/identification
    ) -> None:
        super().__init__(parent)

        self.ui = Ui_histrogramFrame()
        self.ui.setupUi(self)

        self._tag = tag or "Histogram"
        self._bins = int(bins)
        self._data: Optional[np.ndarray] = None
        self._is_float_mode: bool = bool(default_is_float)

        # --- Matplotlib figure inside hist_plot_frame ---
        fig = Figure()
        fig.patch.set_visible(False)  # no outer border
        self._ax = fig.add_axes([0, 0, 1, 1])
        self._ax.set_facecolor("black")
        self._canvas = FigureCanvas(fig)

        # place canvas in the plot frame
        plot_layout = self._require_layout(self.ui.hist_plot_frame)
        plot_layout.addWidget(self._canvas)

        # --- Limit lines (vertical) ---
        self._lower_line = self._ax.axvline(0, color="w", linewidth=1, alpha=0.8)
        self._upper_line = self._ax.axvline(1, color="w", linewidth=1, alpha=0.8)

        # --- Sliders: stacked whole/double ---
        self._whole_slider = QRangeSlider(Qt.Horizontal, self)
        self._double_slider = QDoubleRangeSlider(Qt.Horizontal, self)

        if slider_style:
            # workaround for https://github.com/pyapp-kit/superqt/issues/201
            # self._whole_slider.setStyleSheet(slider_style)
            # self._double_slider.setStyleSheet(slider_style)
            self._whole_slider.setStyleSheet("background:none;")
            self._double_slider.setStyleSheet("background:none;")

        self._stacked_sliders = QtWidgets.QStackedWidget(self)
        self._stacked_sliders.addWidget(self._whole_slider)   # index 0
        self._stacked_sliders.addWidget(self._double_slider)  # index 1
        self._stacked_sliders.setCurrentIndex(1 if self._is_float_mode else 0)

        # Insert slider row just above the Min/Max row
        # vertical layout order is: clip/log, plot, (we insert here), min/max row
        self.ui.range_slider_frame.layout().addWidget(self._stacked_sliders)

        # Keep a convenience reference to the "current" slider
        self._slider = self._current_slider()

        # --- Connections ---
        self._whole_slider.valueChanged.connect(self._on_slider_changed)
        self._double_slider.valueChanged.connect(self._on_slider_changed)

        self.ui.log_checkbox.toggled.connect(self._on_log_toggled)
        # self.ui.clip_checkbox.toggled.connect(self._on_clip_toggled)

        self.ui.min_edit.returnPressed.connect(self._on_min_edit_entered)
        self.ui.max_edit.returnPressed.connect(self._on_max_edit_entered)

        # Some reasonable defaults
        self.set_range(0.0 if self._is_float_mode else 0,
                       1.0 if self._is_float_mode else 1)
        self.set_values(*self.get_range())  # sync lines + edits

        # Draw once
        self._redraw()

    # --------------------------- Public API ---------------------------

    # def set_data(self, data: Iterable[Number], *, auto_range: bool = True) -> None:
    #     """
    #     Set the histogram data. If auto_range=True, slider range & values follow the data min/max.
    #     """
    #     arr = np.asarray(list(data))
    #     # Filter out NaNs/Infs for robust plotting
    #     arr = arr[np.isfinite(arr)]
    #
    #     self._data = arr
    #     self._ax.clear()
    #     self._ax.set_facecolor("black")
    #
    #     # histogram bins
    #     if arr.size > 0:
    #         try:
    #             counts, edges = np.histogram(arr, bins=self._bins)
    #         except Exception:
    #             # fallback if bins invalid
    #             counts, edges = np.histogram(arr, bins=256)
    #
    #         # step-filled look for clean UI
    #         centers = 0.5 * (edges[:-1] + edges[1:])
    #         self._ax.fill_between(centers, counts, step="mid", alpha=0.8, linewidth=0)
    #
    #         # redraw limit lines on top (recreate to ensure on top)
    #         self._lower_line = self._ax.axvline(self.get_values()[0], color="w", linewidth=1, alpha=0.9)
    #         self._upper_line = self._ax.axvline(self.get_values()[1], color="w", linewidth=1, alpha=0.9)
    #     else:
    #         # empty data: keep axes but no bars
    #         self._lower_line = self._ax.axvline(self.get_values()[0], color="w", linewidth=1, alpha=0.9)
    #         self._upper_line = self._ax.axvline(self.get_values()[1], color="w", linewidth=1, alpha=0.9)
    #
    #     # y scale
    #     self._ax.set_yscale("log" if self.ui.log_checkbox.isChecked() else "linear")
    #
    #     if auto_range and arr.size > 0:
    #         dmin = float(np.nanmin(arr))
    #         dmax = float(np.nanmax(arr))
    #         if np.isfinite(dmin) and np.isfinite(dmax):
    #             self.set_range(dmin, dmax)
    #             self.set_values(dmin, dmax)
    #
    #     self._redraw()

    # def set_data(self, data: Iterable, *, auto_range: bool = True) -> None:
    #     """
    #     Set the histogram data. If auto_range=True, slider range & values follow the data min/max.
    #     """
    #     arr = np.asarray(list(data))
    #     arr = arr[np.isfinite(arr)]
    #
    #     self._data = arr
    #     self._ax.clear()
    #     self._ax.set_facecolor("black")
    #
    #     # What scale are we on?
    #     want_log = self.ui.log_checkbox.isChecked()
    #     self._ax.set_yscale("log" if want_log else "linear")
    #
    #     # Defaults in case of empty data
    #     edges = np.array([0.0, 1.0])
    #     counts = np.array([0])
    #
    #     if arr.size > 0:
    #         try:
    #             counts, edges = np.histogram(arr, bins=self._bins)
    #         except Exception:
    #             counts, edges = np.histogram(arr, bins=256)
    #
    #         centers = 0.5 * (edges[:-1] + edges[1:])
    #         # Draw the bars first
    #         if counts.size and counts.max() > 0:
    #             self._ax.fill_between(centers, counts, step="mid", alpha=0.8, linewidth=0)
    #
    #     # ---- Ensure valid axes limits BEFORE drawing vlines ----
    #     # X limits from histogram edges (or defaults)
    #     self._ax.set_xlim(float(edges[0]), float(edges[-1]))
    #
    #     # Y limits: avoid (0,0); log scale requires y>0
    #     maxc = int(counts.max()) if counts.size else 0
    #     if want_log:
    #         ymin = 1  # strictly positive
    #         ymax = max(maxc, 1)
    #     else:
    #         ymin = 0
    #         ymax = max(maxc, 1)
    #     self._ax.set_ylim(ymin, ymax)
    #
    #     # Now draw (or update) the vertical limit lines safely
    #     lo, hi = self.get_values()
    #     # self._lower_line = self._ax.axvline(lo, color="w", linewidth=1, alpha=0.9)
    #     # self._upper_line = self._ax.axvline(hi, color="w", linewidth=1, alpha=0.9)
    #
    #     # Auto-range slider after plot is set up; then sync line positions
    #     if auto_range and arr.size > 0:
    #         dmin = float(np.nanmin(arr))
    #         dmax = float(np.nanmax(arr))
    #         if np.isfinite(dmin) and np.isfinite(dmax):
    #             self.set_range(dmin, dmax)
    #             self.set_values(dmin, dmax)  # also moves the lines
    #
    #     self._redraw()

    def set_data(self, data, disp_lo, disp_hi) -> None:
        """
        Plot the histogram using Matplotlib's Axes.hist.
        """
        import numpy as np

        # --- prepare data ---
        arr = np.asarray(data.flatten())
        arr = arr[np.isfinite(arr)]
        self._data = arr

        ax = self._ax
        ax.cla()
        ax.set_facecolor("black")

        want_log = self.ui.log_checkbox.isChecked()
        ax.set_yscale("log" if want_log else "linear")

        if arr.size == 0:
            # Safe default limits and vlines when no data
            ax.set_xlim(0.0, 1.0)
            ax.set_ylim(1.0, 1.0) if want_log else ax.set_ylim(0.0, 1.0)
            lo, hi = self.get_values()
            self._lower_line = ax.axvline(lo, color="w", linewidth=1, alpha=0.9)
            self._upper_line = ax.axvline(hi, color="w", linewidth=1, alpha=0.9)
            self._redraw()
            return

        # --- compute range from data ---
        dmin = float(np.nanmin(arr))
        dmax = float(np.nanmax(arr))
        if not np.isfinite(dmin) or not np.isfinite(dmax) or dmax <= dmin:
            # fallback if something is off
            dmin, dmax = 0.0, 1.0

        self.set_range(dmin, dmax)

        self.set_values(disp_lo, disp_hi)

        # --- plot the histogram (this is the key change) ---
        counts, bin_edges, _ = ax.hist(
            arr,
            bins=int(self._bins),
            range=(dmin, dmax),
            color="white",
            histtype="stepfilled",
            linewidth=0,
        )

        # --- ensure non-degenerate limits to avoid singular transforms ---
        # X limits from the edges we just used
        ax.set_xlim(float(bin_edges[0]), float(bin_edges[-1]))

        # # Y limits: log scale needs y>0
        # ymax = float(max(counts.max() if counts.size else 1, 1))
        # if want_log:
        #     ax.set_ylim(1.0, ymax)
        # else:
        #     ax.set_ylim(0.0, ymax)

        # --- vertical lines at current slider values ---
        lo, hi = self.get_values()
        self._lower_line = ax.axvline(lo, color='magenta')
        self._upper_line = ax.axvline(hi, color='blue')

        # optional: minimal cosmetics (match your previous snippet’s small labels)
        # ax.set_title("", fontsize=6)
        # ax.yaxis.offsetText.set_fontsize(6)
        # ax.tick_params(axis='both', which='major', labelsize=6, labelcolor='black')
        # ax.yaxis.offsetText.set_fontsize(6)

        # self._redraw()
        self._canvas.draw()

    def set_bins(self, bins: int) -> None:
        self._bins = int(bins)
        if self._data is not None:
            self.set_data(self._data, auto_range=False)

    def use_float_slider(self, enabled: bool) -> None:
        """
        Switch between double/whole slider.
        """
        self._is_float_mode = bool(enabled)
        self._stacked_sliders.setCurrentIndex(1 if enabled else 0)
        self._slider = self._current_slider()
        # # carry over range & values to the newly active slider
        # lo, hi = self.get_values()
        # rlo, rhi = self.get_range()
        # self.set_range(rlo, rhi)
        # self.set_values(lo, hi)

    def set_range(self, min_val: Number, max_val: Number) -> None:
        """
        Set the allowable range of the slider. Also updates the min/max edit placeholders.
        """
        if min_val > max_val:
            min_val, max_val = max_val, min_val

        if self._is_float_mode:
            self._double_slider.setRange(float(min_val), float(max_val))
        else:
            # QRangeSlider expects ints
            self._whole_slider.setRange(int(np.floor(min_val)), int(np.ceil(max_val)))

        # Update min/max edits' text if they currently fall outside
        self._clamp_edits_to_range(min_val, max_val)

    def get_range(self) -> Tuple[Number, Number]:
        """
        Returns the slider's allowable (min, max).
        """
        s = self._current_slider()
        # superqt sliders expose .minimum()/.maximum()
        return (s.minimum(), s.maximum())

    def set_values(self, low: Number, high: Number) -> None:
        """
        Set the current selection values. Also updates edits and limit lines.
        """
        if low > high:
            low, high = high, low

        # clamp to slider range
        rlo, rhi = self.get_range()
        low = max(low, rlo)
        high = min(high, rhi)

        self._current_slider().setValue((low, high))
        self._sync_edits_from_slider()
        self._sync_limit_lines()
        self._redraw()

    def get_values(self) -> Tuple[Number, Number]:
        """
        Current (low, high) values from the active slider.
        """
        v = self._current_slider().value()
        # superqt returns a Tuple[float, float] for double slider, ints for whole slider
        return (v[0], v[1])

    def set_log_checked(self, checked: bool) -> None:
        self.ui.log_checkbox.setChecked(bool(checked))

    def is_log_checked(self) -> bool:
        return self.ui.log_checkbox.isChecked()

    def set_clip_checked(self, checked: bool) -> None:
        self.ui.clip_checkbox.setChecked(bool(checked))

    def is_clip_checked(self) -> bool:
        return self.ui.clip_checkbox.isChecked()

    # ------------------------ Internals / Slots ------------------------

    def _current_slider(self) -> Union[QRangeSlider, QDoubleRangeSlider]:
        return self._double_slider if self._is_float_mode else self._whole_slider

    def _require_layout(self, w: QtWidgets.QWidget) -> QtWidgets.QLayout:
        """
        Ensure a layout exists on a container widget. Create a QVBoxLayout if needed.
        """
        lay = w.layout()
        if lay is None:
            lay = QtWidgets.QVBoxLayout(w)
            lay.setContentsMargins(0, 0, 0, 0)
            lay.setSpacing(0)
        return lay

    def _on_slider_changed(self, vals: Tuple[Number, Number]) -> None:
        # keep edits and limit lines in sync
        self._sync_edits_from_slider()
        self._sync_limit_lines()
        self.rangeChanged.emit(vals[0], vals[1])
        self._redraw()

    def _on_log_toggled(self, checked: bool) -> None:
        self._ax.set_yscale("log" if checked else "linear")
        # self.logToggled.emit(bool(checked))
        self._canvas.draw()

    # def _on_clip_toggled(self, checked: bool) -> None:
    #     self.clipToggled.emit(bool(checked))

    def _on_min_edit_entered(self) -> None:
        lo_txt = self.ui.min_edit.text().strip()
        hi = self.get_values()[1]
        try:
            lo = float(lo_txt) if self._is_float_mode else int(round(float(lo_txt)))
        except ValueError:
            # restore current
            self._sync_edits_from_slider()
            return
        rlo, rhi = self.get_range()
        lo = max(min(lo, rhi), rlo)
        if lo > hi:
            hi = lo
        self.set_values(lo, hi)
        # self.minEdited.emit(lo)
        self.rangeChanged.emit(lo, hi)

    def _on_max_edit_entered(self) -> None:
        hi_txt = self.ui.max_edit.text().strip()
        lo = self.get_values()[0]
        try:
            hi = float(hi_txt) if self._is_float_mode else int(round(float(hi_txt)))
        except ValueError:
            self._sync_edits_from_slider()
            return
        rlo, rhi = self.get_range()
        hi = max(min(hi, rhi), rlo)
        if hi < lo:
            lo = hi
        self.set_values(lo, hi)
        # self.maxEdited.emit(hi)
        self.rangeChanged.emit(lo, hi)

    def _sync_edits_from_slider(self) -> None:
        lo, hi = self.get_values()
        # keep a compact text; no scientific unless needed
        if self._is_float_mode:
            self.ui.min_edit.setText(self._fmt_float(lo))
            self.ui.max_edit.setText(self._fmt_float(hi))
        else:
            self.ui.min_edit.setText(str(int(round(lo))))
            self.ui.max_edit.setText(str(int(round(hi))))

    def _sync_limit_lines(self) -> None:
        lo, hi = self.get_values()
        self._lower_line.set_xdata([lo, lo])
        self._upper_line.set_xdata([hi, hi])

    def _clamp_edits_to_range(self, rlo: Number, rhi: Number) -> None:
        # if edits out-of-range, clamp them
        def _parse(s: str, is_float: bool) -> Optional[Number]:
            try:
                return float(s) if is_float else int(round(float(s)))
            except Exception:
                return None

        cur_lo = _parse(self.ui.min_edit.text().strip(), self._is_float_mode)
        cur_hi = _parse(self.ui.max_edit.text().strip(), self._is_float_mode)

        if cur_lo is None or not (rlo <= cur_lo <= rhi):
            cur_lo = rlo
        if cur_hi is None or not (rlo <= cur_hi <= rhi):
            cur_hi = rhi

        self.set_values(cur_lo, cur_hi)

    def _fmt_float(self, x: float) -> str:
        # nice compact float formatting for medical images
        if x == 0:
            return "0"
        ax = abs(x)
        if ax >= 1000 or (0 < ax < 1e-3):
            return f"{x:.3e}"
        if ax >= 100:
            return f"{x:.1f}"
        if ax >= 10:
            return f"{x:.2f}"
        return f"{x:.3f}"

    def _redraw(self) -> None:
        self._canvas.draw_idle()
