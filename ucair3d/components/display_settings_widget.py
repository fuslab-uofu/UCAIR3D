# display_settings_widget.py
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtWidgets import QStackedWidget, QSizePolicy

from .displaySettingsUI import Ui_displaySettingsFrame  # generated by pyuic5
from .colormap_combo_widget import ColormapCombo
from .discrete_colors_widget import DiscreteColors
from .histogram_widget import Histogram
from .image3D import Image3D

import numpy as np
import cmap
import pyqtgraph as pg


class DisplaySettings(QtWidgets.QFrame):
    """
    Thin wrapper around the Designer UI (Ui_displaySettingsFrame).
    Own this class; never edit the generated file.
    """

    # Payloads your main-window slots already handle:
    # - colormapChanged emits a pyqtgraph.ColorMap (has getLookupTable)
    # - colormapNameChanged emits (image3d, name) if you still want it
    # - paletteChanged emits a uint8 (N,4) RGBA LUT
    # at top of DisplaySettings
    colormap_changed = QtCore.pyqtSignal(str, int)  # (name, index)
    opacity_changed = QtCore.pyqtSignal(float)             # (opacity 0..1.0)

    labelColorChanged = QtCore.pyqtSignal(object, int, object)   # (image3d, label_id, QColor/tuple)
    labelAlphaChanged = QtCore.pyqtSignal(object, int, float)    # (image3d, label_id, alpha 0..1)
    discreteLUTChanged = QtCore.pyqtSignal(object)                   # (uint8 Nx4 palette/LUT)
    histogramChanged = QtCore.pyqtSignal(object)                 # ((min, max))

    def __init__(self, parent=None, *, colormaps=None, discrete_palette=None, tag=None):
        super().__init__(parent)

        self.active_image3D = None

        self.ui = Ui_displaySettingsFrame()
        self.ui.setupUi(self)

        # --- Build stacked area inside the placeholder frame ---
        self._color_settings_stack = QStackedWidget()
        self.ui.color_settings_frame.layout().addWidget(self._color_settings_stack)

        # --- Page 0: ColormapCombo (continuous) ---
        self.colormap_combo = ColormapCombo(
            _parent=self.ui.color_settings_frame,  # frame from Designer
            _colors=colormaps,                     # list of superqt colormaps or names
            _tag=tag or "colormap_combo"
        )
        self._color_settings_stack.addWidget(self.colormap_combo)
        self.colormap_combo.currentIndexChanged.connect(self._on_cmap_index_changed)
        # self.colormap_combo.currentTextChanged.connect(self._handle_colormap_name_changed)

        # --- Page 1: DiscreteColors (discrete) ---
        if discrete_palette is None:
            discrete_palette = np.array([[0, 0, 0, 0], [228, 25, 27, 255]], dtype=np.uint8)
        self.discrete_color_widget = DiscreteColors(_parent=self.ui.color_settings_frame, _color_palette=discrete_palette)
        self._color_settings_stack.addWidget(self.discrete_color_widget)
        self.discrete_color_widget.labelColorChanged.connect(self._handle_label_color_changed)
        self.discrete_color_widget.labelAlphaChanged.connect(self._handle_label_alpha_changed)
        self.discrete_color_widget.lookupTableChanged.connect(self._handle_discrete_LUT_changed)

        # default to continuous on first show
        self._color_settings_stack.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
        self._color_settings_stack.currentChanged.connect(self._on_stack_changed)
        QtCore.QTimer.singleShot(0, lambda: self._on_stack_changed(self._color_settings_stack.currentIndex()))
        self._color_settings_stack.setCurrentIndex(0)

        self.histogram = Histogram(
            self,
            default_is_float=True,
            bins=50
        )
        self.ui.histogram_settings_frame.layout().addWidget(self.histogram)

        self.histogram.rangeChanged.connect(
            lambda vals_lo, vals_hi: self._handle_display_range_changed(vals_lo, vals_hi)
        )

        if self.active_image3D is not None:
            self.histogram.use_float_slider(isinstance(self.active_image3D.data.dtype.type(0), float))
            self.histogram.set_data(self.active_image3D.data.ravel(), auto_range=True)

        # --- Opacity ---
        self.ui.opacity_slider.valueChanged.connect(self._handle_opacity_slider_changed)

        # Start in a cleared/disabled state until an image is set
        self.ui.curr_image_text.setText("(none)")
        self._set_controls_enabled(False)

        self.ui.curr_image_text.setStyleSheet("""
            QLabel {
                background-color: #626568;
                border-color: #626568;
            }
            """)

    # ---------------- Public helpers ----------------
    def set_active_image(self, image):
        """
        Bind the UI to a new active image. Handles both discrete and continuous cases.
        If image is None, clears the UI.
        """
        self.active_image3D = image
        if self.active_image3D is None:
            self.clear_active_image()
            if hasattr(self, "histogram"):
                self.histogram.setVisible(False)
            return

        # Enable editing and label the current image
        self._set_controls_enabled(True)
        self.ui.curr_image_text.setText(
            self.active_image3D.file_name if getattr(self.active_image3D, "file_name", None) else "(unnamed)"
        )

        is_discrete = bool(getattr(self.active_image3D, "is_discrete", False))
        self.set_color_mode(discrete=is_discrete)

        if is_discrete:
            # CHANGED: use labels + LUT from LMVolume
            self.histogram.setVisible(False)
            self.discrete_color_widget.refresh(
                getattr(self.active_image3D, "labels", None),
                getattr(self.active_image3D, "colormap_lut", None)
            )
            QtCore.QTimer.singleShot(0, self._refresh_stack_geometry)
        else:
            # --- Sync the combo box selection to this image's colormap name ---
            # CHANGED: name comes from LMVolume.colormap_source (string)
            name = getattr(self.active_image3D, "colormap_source", None)
            if isinstance(name, str) and name:
                self.colormap_combo.blockSignals(True)
                try:
                    self.set_current_colormap_by_name(name)
                finally:
                    self.colormap_combo.blockSignals(False)

            self._update_histogram_from_image(self.active_image3D)
            self.histogram.setVisible(True)
            QtCore.QTimer.singleShot(0, self._refresh_stack_geometry)

    def clear_active_image(self):
        self.active_image3D = None
        self.ui.curr_image_text.setText("")

        # Show the continuous page by default
        if self._color_settings_stack.currentIndex() != 0:
            self._color_settings_stack.setCurrentIndex(0)

        # Clear continuous editor selection without emitting signals
        self.colormap_combo.blockSignals(True)
        if self.colormap_combo.count() > 0:
            self.colormap_combo.setCurrentIndex(0)
        self.colormap_combo.blockSignals(False)

        # Clear discrete editor
        try:
            self.discrete_color_widget.clear()
        except Exception:
            try:
                self.discrete_color_widget.refresh([], None)
            except Exception:
                pass

        self._set_controls_enabled(False)
        QtCore.QTimer.singleShot(0, self._refresh_stack_geometry)

    def set_color_mode(self, *, discrete: bool) -> None:
        target_idx = 1 if discrete else 0
        if self._color_settings_stack.currentIndex() == target_idx:
            return
        self._color_settings_stack.setCurrentIndex(target_idx)
        self._on_stack_changed(target_idx)

    def show_discrete(self):
        self.set_color_mode(discrete=True)

    def show_continuous(self):
        self.set_color_mode(discrete=False)

    # --- Continuous colormap combo helpers ---
    def set_colormaps(self, colors):
        """
        Replace the options in the combo with a new continuous palette.

        Parameters
        ----------
        colors : Sequence[str] | Sequence[object]
            Either a list of canonical names (preferred) or colormap objects;
            weâ€™ll extract a display label but always store the canonical name
            in UserRole for reliable retrieval.
        """
        # Normalize to a list and remember it
        palette = list(colors or [])
        self._continuous_palette = palette  # keep internal in sync

        self.colormap_combo.blockSignals(True)
        try:
            self.colormap_combo.clear()
            for i, entry in enumerate(palette):
                # Derive display text + canonical name
                if isinstance(entry, str):
                    display = entry
                    canonical = entry
                else:
                    # super defensively try to get a label, but fall back to repr
                    display = getattr(entry, "name", None) or getattr(entry, "label", None) \
                              or getattr(entry, "title", None) or str(entry)
                    # If you have a way to map object -> canonical name, use it here.
                    # Otherwise, display and canonical can be the same.
                    canonical = display

                self.colormap_combo.addItem(display)
                # Store canonical name for retrieval in your handler
                self.colormap_combo.setItemData(i, canonical, QtCore.Qt.UserRole)
                # Optionally: also store the raw object (if not a string)
                if not isinstance(entry, str):
                    self.colormap_combo.setItemData(i, entry, QtCore.Qt.UserRole + 1)
        finally:
            self.colormap_combo.blockSignals(False)

    def current_pyqtgraph_cmap(self):
        """Return the currently selected pyqtgraph colormap (or None)."""
        if self.colormap_combo.count() == 0:
            return None
        try:
            return self.colormap_combo.currentColormap().to_pyqtgraph()
        except Exception:
            return None

    def current_colormap_name(self) -> str:
        return self.colormap_combo.currentText()

    def set_current_colormap_by_name(self, name: str):
        idx = self.colormap_combo.findText(name)
        if idx >= 0:
            self.colormap_combo.setCurrentIndex(idx)

    def set_opacity(self, alpha: float):
        v = int(round(max(0.0, min(1.0, alpha)) * 100))
        if self.ui.opacity_slider.value() != v:
            self.ui.opacity_slider.setValue(v)

    def get_opacity(self) -> float:
        return self.ui.opacity_slider.value() / 100.0

    def refresh(self):
        """
        If is_discrete is True, refresh the discrete color widget with the given labels and LUT.
        If is_discrete is False, sync the colormap combo to the image's colormap name.
        """
        if self.active_image3D is None:
            return

        is_discrete = bool(getattr(self.active_image3D, "is_discrete", False))
        self.set_color_mode(discrete=is_discrete)

        if is_discrete:
            # CHANGED: use LUT, not .colormap
            self.discrete_color_widget.refresh(
                getattr(self.active_image3D, "labels", None),
                getattr(self.active_image3D, "colormap_lut", None)
            )
        else:
            # CHANGED: select by name from LMVolume.colormap_source
            name = getattr(self.active_image3D, "colormap_source", None)
            if isinstance(name, str) and name:
                self.colormap_combo.blockSignals(True)
                try:
                    self.set_current_colormap_by_name(name)
                finally:
                    self.colormap_combo.blockSignals(False)

    # ---------------- Internals ----------------
    def _update_histogram_from_image(self, img) -> None:
        if img is None or getattr(img, "data", None) is None:
            self.histogram.setVisible(False)
            return

        arr = img.data
        if arr.size == 0:
            self.histogram.setVisible(False)
            return

        is_float = np.issubdtype(arr.dtype, np.floating)
        self.histogram.use_float_slider(is_float)

        self.histogram.setVisible(True)
        self.histogram.set_data(arr, img.display_min, img.display_max)

        lo = getattr(img, "display_min", None)
        hi = getattr(img, "display_max", None)
        if lo is not None and hi is not None:
            self.histogram.set_values(lo, hi)

    # ----- Signal handlers -----
    def _handle_threshold_slider_changed(self, vals_lo, vals_hi):
        if self.active_image3D is None or vals_lo is None or vals_hi is None:
            return
        self.histogramChanged.emit((vals_lo, vals_hi))

    def _on_cmap_index_changed(self, idx: int) -> None:
        if self.active_image3D is None or idx < 0:
            return
        name = self.colormap_combo.itemData(idx, QtCore.Qt.UserRole)  # canonical name
        if not name:
            name = self.colormap_combo.itemText(idx)
        if not name:
            return
        self.colormap_changed.emit(name, int(idx))

    def _handle_colormap_name_changed(self, name: str):
        if self.active_image3D is None or not name:
            return
        self.colormapNameChanged.emit(self.active_image3D, name)

    def _handle_label_color_changed(self, label_id: int, color):
        if self.active_image3D is None or label_id is None or color is None:
            return
        # DiscreteColors already updates its internal palette; just bubble up the full LUT
        self.paletteChanged.emit(self.discrete_color_widget.palette)

    def _handle_opacity_slider_changed(self, v: int):
        self.ui.pct_label.setText(f"{v}%")
        self.opacity_changed.emit(v / 100.0)

    def _handle_label_alpha_changed(self, label_id: int, alpha: float):
        if self.active_image3D is None or label_id is None or alpha is None:
            return
        self.labelAlphaChanged.emit(self.active_image3D, label_id, alpha)

    def _handle_discrete_LUT_changed(self, _lut):
        if self.active_image3D is None or _lut is None:
            return
        # palette is expected to be uint8 (N,4); emit directly
        self.discreteLUTChanged.emit(_lut)

    def _handle_display_range_changed(self, vals_lo, vals_hi):
        if self.active_image3D is None or vals_lo is None or vals_hi is None:
            return
        self.histogramChanged.emit((vals_lo, vals_hi))

    def _set_controls_enabled(self, on: bool):
        self.ui.opacity_slider.setEnabled(on)
        self.colormap_combo.setEnabled(on)
        self.discrete_color_widget.setEnabled(on)

    def _refresh_stack_geometry(self):
        page = self._color_settings_stack.currentWidget()
        if not page:
            return
        page.updateGeometry()
        page.adjustSize()
        h = page.sizeHint().height()
        self._color_settings_stack.setMinimumHeight(0)
        self._color_settings_stack.setMaximumHeight(16777215)
        self._color_settings_stack.setMinimumHeight(h)
        self._color_settings_stack.setMaximumHeight(h)
        self._color_settings_stack.updateGeometry()

        host = self.ui.color_settings_frame
        host.setSizePolicy(host.sizePolicy().horizontalPolicy(), QtWidgets.QSizePolicy.Fixed)
        host.setMinimumHeight(0)
        host.setMaximumHeight(16777215)
        host.setMinimumHeight(h)
        host.setMaximumHeight(h)
        host.updateGeometry()

        self.updateGeometry()
        p = self.parent()
        if hasattr(p, "updateGeometry"):
            p.updateGeometry()

    def _on_stack_changed(self, idx: int):
        self._refresh_stack_geometry()
