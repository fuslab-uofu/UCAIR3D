# discrete_colors_widget.py
""" Wrapper for custom discrete colors widget.
Author: Michelle Kline
"""
from PyQt5.QtWidgets import QFrame, QLabel, QPushButton, QColorDialog, QSlider, QScrollArea, QGridLayout, QHBoxLayout
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtGui import QColor

from ..ui.Ui_discreteColors import Ui_DiscreteColorsWidget  # generated by pyuic5
from .platform_utils import get_platform_regular_slider_stylesheet
import cmap
import numpy as np
import pyqtgraph as pg


class DiscreteColors(QFrame):
    labelColorChanged = pyqtSignal(int, object)  # (label_index, QColor)
    labelAlphaChanged = pyqtSignal(int, float)   # (label_index, alpha in [0.0, 1.0])
    lookupTableChanged = pyqtSignal(object)       # emits the whole LUT after any change

    # Number of UI rows in the discrete colors widget (matches the .ui file)
    NUM_UI_ROWS = 20

    def __init__(self, _parent, _color_palette):
        super().__init__(_parent)

        self.parent = _parent
        self.ui = Ui_DiscreteColorsWidget()
        self.ui.setupUi(self)

        # _LUT expected as array-like RGBA 0..255
        self.color_palette = _color_palette

        # # make initial pyqtgraph colormap from full LUT
        # colors_0_1 = (self.lut / 255.0)
        # colors = cmap.Colormap(colors_0_1)
        # self.colormap = colors.to_pyqtgraph()  # pyqtgraph.ColorMap

        # compare number of rows in the UI vs number of colors in the LUT, and adjust UI if needed
        ui_rows = self.NUM_UI_ROWS
        if len(self.color_palette) > ui_rows:
            # TODO: dynamically add more rows to the UI if needed
            print(f"Warning: Color palette has {len(self.color_palette)} colors, but UI only has {ui_rows} rows. Some colors will be inaccessible.")
        elif len(self.color_palette) < ui_rows:
            # hide unused rows
            for i in range(len(self.color_palette), ui_rows):
                label_widget = self.findChild(QLabel, f'label_label_{i}')
                if label_widget:
                    label_widget.setVisible(False)
                color_button = self.findChild(QPushButton, f'label_button_{i}')
                if color_button:
                    color_button.setVisible(False)
                alpha_slider = self.findChild(QSlider, f'alpha_slider_{i}')
                if alpha_slider:
                    alpha_slider.setVisible(False)
                alpha_label = self.findChild(QLabel, f'pct_label_{i}')
                if alpha_label:
                    alpha_label.setVisible(False)

        # tag the widgets with the index of the color in the colormap, and connect slots
        for i in range(len(self.color_palette)):  # self.color_palette.getColors().shape[0]
            color_button = self.findChild(QPushButton, f'label_button_{i}')
            if color_button:
                color_button.setProperty('tag', i)
                color_button.clicked.connect(self.color_button_clicked)
                color_button.setEnabled(False)

            opacity_slider = self.findChild(QSlider, f'alpha_slider_{i}')
            if opacity_slider:
                opacity_slider.setProperty('tag', i)
                opacity_slider.valueChanged.connect(self.opacity_slider_changed)
                opacity_slider.setEnabled(False)
                
                # Apply platform-specific styling to opacity slider
                opacity_stylesheet = get_platform_regular_slider_stylesheet()
                opacity_slider.setStyleSheet(opacity_stylesheet)

    def _ensure_uint8_rgba(self, colors, n_labels):
        if isinstance(colors, pg.ColorMap):
            return colors.getLookupTable(nPts=n_labels, alpha=True).astype(np.uint8)
        arr = np.asarray(colors)
        if arr.ndim == 2 and arr.shape[1] in (3, 4):
            if np.issubdtype(arr.dtype, np.floating) and arr.max() <= 1.0:
                arr = (arr * 255).round()
            arr = arr.clip(0, 255).astype(np.uint8)
            if arr.shape[1] == 3:
                a = np.full((arr.shape[0], 1), 255, dtype=np.uint8)
                arr = np.hstack([arr, a])
            return arr
        if isinstance(colors, tuple) and len(colors) == 2:
            stops, cols = colors
            cm = pg.ColorMap(np.asarray(stops, float), np.asarray(cols, float)[:, :3])
            return cm.getLookupTable(nPts=n_labels, alpha=True).astype(np.uint8)
        raise TypeError("Unsupported discrete colors format")

    def refresh(self, _labels, _colors):
        if _labels is None or _colors is None:
            return

        # _colors assumed to be pyqtgraph.ColorMap with 0..255 RGBA from getColors()
        lut = self._ensure_uint8_rgba(_colors, n_labels=len(_labels) or 256)
        self.lut = lut

        # sanity check
        assert len(_labels) <= self.lut.shape[0]

        for i in range(len(_labels)):
            label_id_text = "Background" if i == 0 else f'Label {i}: {_labels[i]}'

            label_widget = self.findChild(QLabel, f'label_label_{i}')
            if label_widget:
                label_widget.setText(label_id_text)
                label_widget.setVisible(True)

            color_button = self.findChild(QPushButton, f'label_button_{i}')
            if color_button:
                color_button.setEnabled(True)
                r, g, b, a = self.lut[i]  # 0..255
                color_button.setStyleSheet(
                    f"""QPushButton#label_button_{i} {{
                        background-color: rgba({r}, {g}, {b}, 255);
                        border: 0.04em solid rgba({r}, {g}, {b}, 255);
                    }}"""
                )
                color_button.setVisible(True)

            alpha_slider = self.findChild(QSlider, f'alpha_slider_{i}')
            if alpha_slider:
                alpha_slider.setEnabled(True)
                alpha_val = round(self.convert_range(a, 0, 255, 0, 100))  # slider 0..100
                alpha_slider.blockSignals(True)
                alpha_slider.setValue(alpha_val)
                alpha_slider.blockSignals(False)
                alpha_slider.setVisible(True)

            alpha_label = self.findChild(QLabel, f'pct_label_{i}')
            if alpha_label:
                alpha_label.setText(f'{alpha_val}%')
                alpha_label.setVisible(True)

        # Hide any unused rows beyond the number of labels
        # We need to hide from len(_labels) to NUM_UI_ROWS (not just to len(self.lut))
        for i in range(len(_labels), self.NUM_UI_ROWS):
            color_button = self.findChild(QPushButton, f'label_button_{i}')
            if color_button:
                color_button.setStyleSheet(
                    f"""QPushButton#label_button_{i} {{
                        background-color: #31363b;
                        border: 0.04em solid #76797c;
                    }}"""
                )
                color_button.setEnabled(False)
                color_button.setVisible(False)

            alpha_slider = self.findChild(QSlider, f'alpha_slider_{i}')
            if alpha_slider:
                alpha_slider.setEnabled(False)
                alpha_slider.setVisible(False)
            label_widget = self.findChild(QLabel, f'label_label_{i}')
            if label_widget:
                label_widget.setText('')
                label_widget.setVisible(False)
            alpha_label = self.findChild(QLabel, f'pct_label_{i}')
            if alpha_label:
                alpha_label.setText('')
                alpha_label.setVisible(False)
        
        # Force layout update after showing/hiding widgets to ensure proper geometry calculation
        scroll_area = self.findChild(QScrollArea)
        if scroll_area:
            scroll_widget = scroll_area.widget()
            if scroll_widget:
                scroll_widget.updateGeometry()
                scroll_widget.adjustSize()
                scroll_widget.update()  # Force repaint
            scroll_area.updateGeometry()
            scroll_area.update()  # Force repaint
            # Ensure scroll area is scrolled to the top to show the first rows
            scroll_area.verticalScrollBar().setValue(0)
        self.updateGeometry()
        self.adjustSize()
        self.update()  # Force repaint to ensure widgets are visible

    def clear(self):
        """
        Reset the UI and model to an empty/neutral state:
          - hide/disable all rows
          - reset styles and labels
          - set a minimal background-only colormap
        """
        # Minimal transparent background LUT (1 row)
        self.lut = np.array([[0, 0, 0, 0]], dtype=np.uint8)
        # self.colormap = cmap.Colormap((self.lut / 255.0)).to_pyqtgraph()

        # Number of UI rows designed in the .ui
        ui_rows = self.NUM_UI_ROWS

        for i in range(ui_rows):
            # Label text
            label_widget = self.findChild(QLabel, f"label_label_{i}")
            if label_widget:
                label_widget.setText("")
                label_widget.setVisible(False)

            # Swatch button
            color_button = self.findChild(QPushButton, f"label_button_{i}")
            if color_button:
                color_button.setEnabled(False)
                color_button.setVisible(False)
                # Neutral dark style (same as your refresh() 'unfilled' case)
                color_button.setStyleSheet(
                    f"""QPushButton#label_button_{i} {{
                            background-color: #31363b;
                            border: 0.04em solid #76797c;
                       }}"""
                )

            # Alpha slider
            alpha_slider = self.findChild(QSlider, f"alpha_slider_{i}")
            if alpha_slider:
                alpha_slider.blockSignals(True)
                alpha_slider.setValue(0)  # 0% for a cleared state
                alpha_slider.blockSignals(False)
                alpha_slider.setEnabled(False)
                alpha_slider.setVisible(False)

            # Alpha percent label
            alpha_label = self.findChild(QLabel, f"pct_label_{i}")
            if alpha_label:
                alpha_label.setText("")
                alpha_label.setVisible(False)

        # Do NOT emit LookupTableChanged here; clearing is a UI reset, not a user edit.

    def color_button_clicked(self):
        which_button = self.sender()
        colormap_index = which_button.property('tag')

        # r, g, b, a = self.colormap.getColors()[colormap_index]  # 0..255 ints
        r, g, b, a = self.lut[colormap_index]  # 0..255 ints
        initial_color = QColor(int(r), int(g), int(b), int(a))

        dlg = QColorDialog(self)
        dlg.setCurrentColor(initial_color)
        # dlg.setOption(QColorDialog.ShowAlphaChannel, True)  # enable if you want RGBA in the dialog
        if dlg.exec_() == QColorDialog.Accepted:
            new_color = dlg.currentColor()
            if new_color.isValid():
                # Update colormap RGB (keep original alpha)
                # self.colormap.getColors()[colormap_index] = [
                #     new_color.red(), new_color.green(), new_color.blue(), int(a)
                # ]
                self.lut[colormap_index] = [
                    new_color.red(), new_color.green(), new_color.blue(), int(a)
                ]

                # Update swatch button appearance
                which_button.setStyleSheet(
                    f"""QPushButton#label_button_{colormap_index} {{
                        background-color: rgba({new_color.red()},{new_color.green()},{new_color.blue()},255);
                        border: 0.04em solid rgba({new_color.red()},{new_color.green()},{new_color.blue()},255);
                    }}"""
                )

                # Emit fine-grained & aggregate signals
                # self.labelColorChanged.emit(int(colormap_index), new_color)
                self.lookupTableChanged.emit(self.lut)

    def opacity_slider_changed(self, val):
        which_slider = self.sender()
        colormap_index = which_slider.property('tag')

        # r, g, b, a = self.colormap.getColors()[colormap_index]
        r, g, b, a = self.lut[colormap_index]
        # update percent label
        pct_label = self.findChild(QLabel, f'pct_label_{colormap_index}')
        if pct_label:
            pct_label.setText(f'{val}%')

        new_alpha_255 = round(self.convert_range(val, 0, 100, 0, 255))
        self.lut[colormap_index] = [int(r), int(g), int(b), int(new_alpha_255)]        
        # self.lut[colormap_index] = [int(r), int(g), int(b), int(val)]

        # Emit fine-grained & aggregate signals
        alpha_0_1 = float(self.convert_range(val, 0, 100, 0.0, 1.0))
        self.labelAlphaChanged.emit(int(colormap_index), alpha_0_1)
        # self.LookupTableChanged.emit(self.colormap)

    def convert_range(self, value, old_min, old_max, new_min, new_max):
        return ((value - old_min) * (new_max - new_min) / (old_max - old_min)) + new_min
    
    def get_content_height(self):
        """
        Calculate the actual height needed for the discrete colors widget based on visible rows.
        Returns the height in pixels, or None if unable to calculate.
        """
        if not hasattr(self, 'lut') or self.lut is None:
            return None
        
        # Get the scroll area and its contents
        scroll_area = self.findChild(QScrollArea)
        if not scroll_area:
            return None
        
        scroll_widget = scroll_area.widget()
        if not scroll_widget:
            return None
        
        # Get the grid layout
        grid_layout = scroll_widget.findChild(QGridLayout)
        if not grid_layout:
            return None
        
        # Force the layout to update and calculate its size hint
        scroll_widget.updateGeometry()
        scroll_widget.adjustSize()
        grid_layout.invalidate()
        grid_layout.activate()
        
        # Get the actual size hint of the scroll widget contents
        scroll_content_height = scroll_widget.sizeHint().height()
        if scroll_content_height <= 0:
            # Fallback: use LUT length to determine number of rows
            # This is more reliable than counting visible widgets, which may not be visible yet
            num_rows = len(self.lut) if self.lut is not None else 0
            
            if num_rows == 0:
                return None
            
            # Estimate: each row is ~25px (label height + spacing)
            row_height = 25
            margins = grid_layout.contentsMargins()
            scroll_content_height = num_rows * row_height + margins.top() + margins.bottom()
        
        # Get fixed heights of other elements in the main layout
        fixed_elements_height = 0
        
        # Line separator (2px)
        line = self.findChild(QFrame, 'line')
        if line:
            line_h = line.sizeHint().height()
            fixed_elements_height += line_h if line_h > 0 else 2
        
        # "Overall Opacity" label
        opacity_label = self.findChild(QLabel, 'label_4')
        if opacity_label:
            label_h = opacity_label.sizeHint().height()
            fixed_elements_height += label_h if label_h > 0 else 24
        
        # Opacity slider layout
        opacity_layout = self.findChild(QHBoxLayout, 'horizontalLayout')
        if opacity_layout:
            fixed_elements_height += opacity_layout.sizeHint().height() or 30
        else:
            fixed_elements_height += 30  # fallback
        
        # Get the main layout to account for margins and spacing
        main_layout = self.layout()
        if main_layout:
            margins = main_layout.contentsMargins()
            spacing = main_layout.spacing()
            # Count spacing between elements (scroll area, line, label, slider)
            layout_overhead = margins.top() + margins.bottom() + spacing * 3
        else:
            layout_overhead = 10  # fallback
        
        total_height = scroll_content_height + fixed_elements_height + layout_overhead
        
        return total_height

